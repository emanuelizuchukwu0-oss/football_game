<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>1vN Football ‚Äî Levels</title>
<style>
  html,body{height:100%;margin:0;background:#1b5e20;display:flex;align-items:center;justify-content:center;font-family:Arial, sans-serif}
  #container{position:relative;width:100%;height:100vh;display:flex;align-items:center;justify-content:center}
  canvas{background:linear-gradient(#0b6623,#0b8c37);box-shadow:0 6px 20px rgba(0,0,0,0.6);border-radius:6px}
  /* UI */
  .hud{position:absolute;left:12px;top:12px;color:#fff;z-index:20;text-shadow:0 1px 2px rgba(0,0,0,0.6)}
  .hud div{margin-bottom:6px}
  .overlays{position:absolute;z-index:30;display:flex;align-items:center;justify-content:center;flex-direction:column}
  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);color:#fff;flex-direction:column}
  .overlay.show{display:flex}
  .panel{background:#0c7f3a;padding:24px;border-radius:8px;box-shadow:0 8px 40px rgba(0,0,0,0.6);text-align:center}
  .btn{margin:8px;padding:10px 18px;background:#fff;color:#0c7f3a;border-radius:6px;border:none;cursor:pointer;font-weight:bold}
  /* mobile controls */
  .touch-controls{position:absolute;z-index:25;bottom:18px;left:18px;display:none;gap:10px}
  .touch-controls.right{left:auto;right:18px}
  .tc-button{width:64px;height:64px;border-radius:10px;background:rgba(255,255,255,0.14);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;font-size:18px;box-shadow:inset 0 -3px 0 rgba(0,0,0,0.2)}
  @media (pointer:coarse) {
    .touch-controls{display:flex}
    canvas{transform:rotate(180deg); /* "opposite direction" for mobile as requested */ }
  }
  /* small text */
  .small{font-size:12px;opacity:0.9}
</style>
</head>
<body>
<div id="container">
  <canvas id="gameCanvas" width="1200" height="800"></canvas>

  <div class="hud" id="hud">
    <div id="levelText">Level: 1</div>
    <div id="livesText">Lives: 7</div>
    <div id="possessionText">Possession: --</div>
    <div id="stealTimerText">Steal timer: --</div>
    <div id="message" class="small"></div>
  </div>

  <div class="overlays">
    <div id="winOverlay" class="overlay">
      <div class="panel">
        <h1>YOU WIN!</h1>
        <div style="font-size:40px">üëçüëçüëç</div>
        <div style="margin-top:12px">
          <button class="btn" id="replayBtnWin">Play Again</button>
          <button class="btn" id="nextBtn">Next Chapter</button>
        </div>
      </div>
    </div>

    <div id="loseOverlay" class="overlay">
      <div class="panel">
        <h1>YOU LOST</h1>
        <div style="margin-top:12px">
          <button class="btn" id="replayBtnLose">Play Level Again</button>
        </div>
      </div>
    </div>

    <div id="goalPopup" class="overlay" style="pointer-events:none; background:transparent;">
      <div style="font-size:72px;color:yellow;text-shadow:0 6px 14px rgba(0,0,0,0.7);display:none" id="goalText">GOALLLL!!!</div>
    </div>
  </div>

  <!-- Touch controls -->
  <div class="touch-controls left" id="leftControls">
    <div style="display:flex;flex-direction:column;gap:8px">
      <div style="display:flex;gap:8px">
        <div class="tc-button" id="btnUp">‚Üë</div>
      </div>
      <div style="display:flex;gap:8px">
        <div class="tc-button" id="btnLeft">‚Üê</div>
        <div class="tc-button" id="btnDown">‚Üì</div>
        <div class="tc-button" id="btnRight">‚Üí</div>
      </div>
    </div>
  </div>

  <div class="touch-controls right" id="rightControls">
    <div style="display:flex;flex-direction:column;gap:8px">
      <div class="tc-button" id="btnSteal">S</div>
      <div class="tc-button" id="btnShoot">‚öΩ</div>
    </div>
  </div>

</div>

<script>
/*
  1vN football game single-file.
  Note: This is a working demo that implements your requested features with a simple AI.
*/

// ---------- Utility ----------
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
function distanceXY(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return Math.sqrt(dx*dx+dy*dy); }

// ---------- Ball ----------
class Ball {
  constructor(x,y){
    this.x=x; this.y=y;
    this.radius=12;
    this.vx=0; this.vy=0;
    this.friction=0.985;
    this.possessedBy=null;
    this.lastTouchedBy=null;
  }
  update(){
    if(this.possessedBy) {
      // follows player slightly ahead
      const owner = this.possessedBy;
      const offset = owner.isHome ? 26 : -26;
      this.x = owner.x + offset;
      this.y = owner.y;
      this.vx = 0; this.vy = 0;
      return;
    }
    // physics
    this.vx *= this.friction; this.vy *= this.friction;
    this.x += this.vx; this.y += this.vy;
    // bounce on pitch edges
    if(this.x - this.radius < 0) { this.x = this.radius; this.vx *= -0.6; this.outTouched=true; }
    if(this.x + this.radius > 1200) { this.x = 1200 - this.radius; this.vx *= -0.6; this.outTouched=true; }
    if(this.y - this.radius < 0) { this.y = this.radius; this.vy *= -0.6; this.outTouched=true; }
    if(this.y + this.radius > 800) { this.y = 800 - this.radius; this.vy *= -0.6; this.outTouched=true; }
    if(Math.abs(this.vx) < 0.02) this.vx = 0;
    if(Math.abs(this.vy) < 0.02) this.vy = 0;
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.ellipse(4, 10, this.radius*1.1, this.radius*0.5, 0, 0, Math.PI*2); ctx.fill();
    // ball
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.stroke();
    // simple pattern
    ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(-4,-2,3,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

// ---------- Player ----------
class Player {
  constructor(cfg){
    this.x = cfg.x; this.y = cfg.y;
    this.isHome = !!cfg.isHome;
    this.color = cfg.color || (this.isHome ? '#ff3b30' : '#0b63ff');
    this.secondary = cfg.secondary || '#fff';
    this.number = cfg.number || 0;
    this.position = cfg.position || 'CM';
    this.radius = 14;
    this.vx=0; this.vy=0;
    this.speedBase = cfg.speedBase || (2 + Math.random()*1.5);
    this.speed = this.speedBase;
    this.hasBall=false;
    this.isUser = !!cfg.isUser;
    this.isRemoved=false; // red-carded
    // attributes
    this.shooting = cfg.shooting || (0.5 + Math.random()*0.5);
    this.passing = cfg.passing || (0.5 + Math.random()*0.5);
    this.tackling = cfg.tackling || (0.5 + Math.random()*0.5);
    this.aggression = cfg.aggression || (0.4 + Math.random()*0.6);
    this.stamina = 1.0;
    this.role = cfg.role || 'mid';
    // AI helpers
    this.targetX = this.x; this.targetY = this.y;
    this.actionTimer = 0;
    this.supportPos = {x:this.x,y:this.y};
    this.formationX = cfg.formX || this.x;
    this.formationY = cfg.formY || this.y;
    // animations
    this.legSwing = 0; this.armSwing=0; this.animFrame=0;
    this.kickFrame = 0; this.tackleFrame = 0;
    // for steal timer logic
    this.lastPossessionTime = 0;
  }

  update(dt, game){
    if(this.isRemoved) return;
    // stamina regen/drain
    if(Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) this.stamina = Math.max(0.2, this.stamina - 0.0005 * dt);
    else this.stamina = Math.min(1, this.stamina + 0.0008 * dt);

    // user control handled externally
    if(!this.isUser){
      this.updateAI(dt,game);
    } else {
      // some friction
      this.vx *= 0.9; this.vy *= 0.9;
    }

    // movement
    this.x += this.vx; this.y += this.vy;
    // clamp to pitch
    this.x = clamp(this.x, this.radius, 1200 - this.radius);
    this.y = clamp(this.y, this.radius, 800 - this.radius);

    // animations
    this.animFrame++;
    this.legSwing = Math.sin(this.animFrame * 0.25) * (Math.abs(this.vx) + Math.abs(this.vy)) * 6;
    this.armSwing = Math.cos(this.animFrame * 0.25) * (Math.abs(this.vx) + Math.abs(this.vy)) * 4;
  }

  updateAI(dt, game){
    // Simple role-based AI: if team has ball, support or press; if opponent has ball, mark/press; free ball -> chase if close
    const ball = game.ball;
    const teamHasBall = ball.possessedBy && ball.possessedBy.isHome === this.isHome;
    const distToBall = distanceXY(this.x,this.y, ball.x, ball.y);

    // occasionally pick new target
    if(this.actionTimer <= 0){
      this.actionTimer = 30 + Math.random()*60;
      if(teamHasBall){
        // support play: move to supportive position between ball and goal
        const direction = this.isHome ? 1 : -1;
        this.targetX = clamp(ball.x + (50 * direction) + rand(-40,40), this.radius, 1200 - this.radius);
        this.targetY = clamp(ball.y + rand(-80,80), this.radius, 800 - this.radius);
      } else {
        // opponent has ball: mark or try to intercept if close
        if(ball.possessedBy && ball.possessedBy.isHome !== this.isHome){
          if(distToBall < 140 && Math.random() < 0.7){
            this.targetX = ball.x; this.targetY = ball.y;
          } else {
            // mark opponent positions: stay between ball and goal
            const goalX = this.isHome ? 50 : 1150;
            this.targetX = clamp((ball.x + goalX)/2 + rand(-30,30), this.radius, 1200 - this.radius);
            this.targetY = clamp(ball.y + rand(-40,40), this.radius, 800 - this.radius);
          }
        } else {
          // free ball: go for it if close, otherwise return to formation
          if(distToBall < 180 && Math.random() < 0.7){
            this.targetX = ball.x; this.targetY = ball.y;
          } else {
            this.targetX = this.formationX + rand(-20,20);
            this.targetY = this.formationY + rand(-20,20);
          }
        }
      }
    } else {
      this.actionTimer -= 1;
    }

    // move to target
    const dx = this.targetX - this.x; const dy = this.targetY - this.y;
    const d = Math.sqrt(dx*dx + dy*dy) || 1;
    const desiredSpeed = this.speedBase * (0.6 + this.stamina*0.8) * (1 + this.aggression*0.1);
    this.vx += (dx/d) * desiredSpeed * 0.12;
    this.vy += (dy/d) * desiredSpeed * 0.12;
    // limit velocity
    const max = desiredSpeed*1.2;
    const sp = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
    if(sp > max){ this.vx = this.vx/sp*max; this.vy = this.vy/sp*max; }

    // If close to ball and not possessed by own team, try to tackle or take possession
    if(ball.possessedBy && ball.possessedBy.isHome !== this.isHome && distToBall < 28){
      // attempt tackle
      if(Math.random() < this.tackling*0.4){
        const success = Math.random() < (this.tackling*0.5 + 0.2);
        if(success){
          // take ball
          ball.possessedBy.hasBall = false;
          ball.possessedBy = this;
          this.hasBall = true;
          ball.lastTouchedBy = this;
          game.onPossessionChange(this);
        }
      }
    }

    // If has ball: sometimes pass/shoot based on distance
    if(this.hasBall && ball.possessedBy === this){
      const goalX = this.isHome ? 1150 : 50;
      const distGoal = Math.abs(goalX - this.x);
      // if close to goal attempt shot with probability based on shooting attribute
      if(distGoal < 220 && Math.random() < 0.006 * this.shooting * (1 + game.level*0.06)){
        // shoot
        const angle = Math.atan2(400 - this.y, goalX - this.x);
        const power = 10 + (this.shooting*6) + (Math.random()*4);
        ball.vx = Math.cos(angle)*power; ball.vy = Math.sin(angle)*power;
        ball.possessedBy = null; this.hasBall=false;
        ball.lastTouchedBy = this;
        game.onShot(this);
      } else if(Math.random() < 0.02 * this.passing){
        // attempt pass to teammate in front
        const teammates = game.players.filter(p => p.isHome === this.isHome && p !== this && !p.isRemoved);
        if(teammates.length){
          // choose a forward teammate (higher progress)
          teammates.sort((a,b)=> (this.isHome ? b.x-a.x : a.x-b.x) + (Math.random()*50));
          const target = teammates[0];
          // good pass if distance is reasonable
          const dxp = target.x - this.x, dyp = target.y - this.y;
          const a = Math.atan2(dyp, dxp);
          const pwr = clamp(5 + Math.sqrt(dxp*dxp + dyp*dyp)/60, 6, 14);
          ball.vx = Math.cos(a) * pwr; ball.vy = Math.sin(a) * pwr;
          ball.possessedBy = null; this.hasBall=false;
          ball.lastTouchedBy = this;
          game.onPass(this, target);
        }
      }
    }
  }

  draw(ctx){
    if(this.isRemoved) return;
    ctx.save();
    ctx.translate(this.x, this.y);

    // body
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.ellipse(0,0, this.radius*0.9, this.radius*1.2, 0, 0, Math.PI*2);
    ctx.fill();

    // shorts
    ctx.fillStyle = this.secondary;
    ctx.fillRect(-this.radius, 6, this.radius*2, 8);

    // head
    ctx.fillStyle = '#ffddc1';
    ctx.beginPath(); ctx.arc(0, -18, 10, 0, Math.PI*2); ctx.fill();

    // hair
    ctx.fillStyle = '#2C3E50';
    ctx.fillRect(-8,-25,16,6);

    // eyes
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(-3,-19,1.6,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(3,-19,1.6,0,Math.PI*2); ctx.fill();

    // arms (animated)
    ctx.save();
    ctx.rotate(this.armSwing*0.02);
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.radius-4, -6, 6, 3);
    ctx.restore();
    ctx.save();
    ctx.rotate(-this.armSwing*0.02);
    ctx.fillStyle = this.color;
    ctx.fillRect(this.radius-2, -6, 6, 3);
    ctx.restore();

    // legs
    ctx.fillStyle = this.secondary;
    ctx.save(); ctx.rotate(this.legSwing*0.02); ctx.fillRect(-6, 12, 5, 18); ctx.restore();
    ctx.save(); ctx.rotate(-this.legSwing*0.02); ctx.fillRect(1, 12, 5, 18); ctx.restore();

    // number
    ctx.fillStyle = '#fff'; ctx.font = 'bold 10px Arial'; ctx.textAlign='center'; ctx.fillText(this.number, 0, 2);

    // possession marker
    if(this.hasBall){
      ctx.fillStyle = 'gold';
      ctx.beginPath(); ctx.arc(18, -8, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#000'; ctx.font='8px Arial'; ctx.fillText('‚öΩ', 18, -8);
    }

    ctx.restore();
  }

  trySteal(ball, game){
    // called when user presses steal button nearby
    if(this.isRemoved) return false;
    if(ball.possessedBy && ball.possessedBy.isHome !== this.isHome){
      const holder = ball.possessedBy;
      const d = distanceXY(this.x,this.y, holder.x, holder.y);
      if(d < 50){
        // steal chance depends on attributes and randomness
        const chance = 0.45 * (this.tackling + (this.stamina*0.6)) - 0.15*(holder.aggression||0) + rand(-0.1,0.1);
        if(Math.random() < chance){
          // successful steal
          holder.hasBall = false;
          this.hasBall = true;
          ball.possessedBy = this;
          game.onPossessionChange(this);
          return true;
        } else {
          // failed steal attempt: small pushback
          this.vx += (this.x - holder.x) * 0.05; this.vy += (this.y - holder.y) * 0.05;
          return false;
        }
      }
    }
    return false;
  }

  attemptShoot(ball, powerScale=1, game=null){
    if(!this.hasBall || ball.possessedBy !== this) return false;
    const goalX = this.isHome ? 1150 : 50;
    const goalY = 400;
    const angle = Math.atan2(goalY - this.y, goalX - this.x);
    const distanceToGoal = Math.abs(goalX - this.x);
    // power scaled by shooting stat and requested power
    const power = clamp(8 + this.shooting*8 + powerScale*6 + distanceToGoal/80, 6, 22);
    ball.vx = Math.cos(angle)*power; ball.vy = Math.sin(angle)*power;
    ball.possessedBy = null; this.hasBall=false; ball.lastTouchedBy = this;
    game.onShot(this);
    return true;
  }
}

// ---------- Referee ----------
class Referee {
  constructor(){
    this.x = 600; this.y=380;
    this.color = '#222';
    this.wanderingTarget = {x:600,y:380};
    this.timer = 0;
    this.whistleCooldown = 0;
  }
  update(){
    this.timer--;
    if(this.timer <= 0){
      this.timer = 120 + Math.random()*200;
      this.wanderingTarget.x = 200 + Math.random()*800;
      this.wanderingTarget.y = 150 + Math.random()*500;
    }
    // move slowly
    const dx = this.wanderingTarget.x - this.x;
    const dy = this.wanderingTarget.y - this.y;
    this.x += dx*0.02; this.y += dy*0.02;
    if(this.whistleCooldown>0) this.whistleCooldown--;
  }
  blowWhistle(){
    this.whistleCooldown = 60;
  }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y);
    // body
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.ellipse(0,0,12,20,0,0,Math.PI*2); ctx.fill();
    // head
    ctx.fillStyle='#f8d7b1'; ctx.beginPath(); ctx.arc(0,-26,8,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff';
    if(this.whistleCooldown > 0){
      ctx.fillStyle='yellow';
      ctx.font='bold 14px Arial';
      ctx.fillText('üîî', -6, -36);
    }
    ctx.restore();
  }
}

// ---------- Game ----------
class Game {
  constructor(canvas){
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.ball = new Ball(600,400);
    this.players = [];
    this.ref = new Referee();
    this.level = 1;
    this.lives = 7;
    this.maxLevel = 22;
    this.userPlayer = null;
    this.goalCooldown = 0;
    this.possessionTimer = 0; // timer when opponent has ball for life deduction
    this.possessionOwner = null;
    this.levelInProgress = false;
    this.message = '';
    this.goalPopupTimer = 0;
    this.initInput();
    this.lastFrame = performance.now();
    this.createLevel(this.level);
    this.hud = {
      levelText: document.getElementById('levelText'),
      livesText: document.getElementById('livesText'),
      possessionText: document.getElementById('possessionText'),
      stealTimerText: document.getElementById('stealTimerText'),
      message: document.getElementById('message')
    };
    this.winOverlay = document.getElementById('winOverlay');
    this.loseOverlay = document.getElementById('loseOverlay');
    this.goalTextEl = document.getElementById('goalText');
    document.getElementById('replayBtnWin').onclick = ()=> this.restartLevel();
    document.getElementById('nextBtn').onclick = ()=> this.nextLevel();
    document.getElementById('replayBtnLose').onclick = ()=> this.restartLevel();
    this.loop();
  }

  createLevel(level){
    // clear
    this.players.length = 0;
    this.ball = new Ball(600,400);
    this.ref = new Referee();
    this.level = level;
    this.levelInProgress = true;
    this.message = '';
    this.goalPopupTimer = 0;

    // Create user player at left center (home)
    const user = new Player({
      x: 200, y: 400, isHome:true, color:'#ff3b30', secondary:'#c0392b', number:10,
      isUser:true, speedBase:3.2, shooting:0.7, passing:0.6, tackling:0.55, role:'attacker',
      formX:200, formY:400
    });
    this.userPlayer = user;
    this.players.push(user);

    // create opposing team players: start with N opponents (level)
    const opponentsCount = Math.min(level, this.maxLevel); // 1..22
    // For simplicity opponent team placed on right half
    for(let i=0;i<opponentsCount;i++){
      const posX = clamp(900 + rand(-60,60), 700, 1150);
      const posY = clamp(150 + i * (600 / Math.max(1,opponentsCount)), 100, 700);
      const p = new Player({
        x: posX + rand(-40,40), y: posY + rand(-30,30),
        isHome:false, color:'#0b63ff', secondary:'#0b3cff',
        number: 20+i, speedBase:2.2 + (level*0.03), shooting:0.5 + (level*0.01),
        passing:0.5 + (level*0.01), tackling:0.5 + (level*0.01),
        role: (i===0 ? 'attacker' : i<3? 'mid':'defender'),
        formX:posX, formY:posY
      });
      this.players.push(p);
    }

    // give ball to random opponent at start
    const opps = this.players.filter(p => !p.isUser && !p.isRemoved);
    const holder = opps[Math.floor(Math.random()*opps.length)];
    holder.hasBall = true;
    this.ball.possessedBy = holder;
    this.ball.lastTouchedBy = holder;
    this.onPossessionChange(holder, true);
    this.hud.levelText.innerText = `Level: ${this.level}`;
    this.hud.livesText.innerText = `Lives: ${this.lives}`;
  }

  initInput(){
    this.keys = {};
    window.addEventListener('keydown', e=>{
      this.keys[e.key] = true;
      // prevent scrolling for arrow keys and space
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      // steal
      if(e.key.toLowerCase() === 's') {
        if(this.userPlayer) {
          const ok = this.userPlayer.trySteal(this.ball, this);
          if(ok) this.hud.message.innerText = 'Steal successful!';
        }
      }
      // shoot
      if(e.code === 'Space') {
        if(this.userPlayer) {
          const fired = this.userPlayer.attemptShoot(this.ball, 1.0, this);
          if(fired) this.hud.message.innerText = 'Shoot!';
        }
      }
    });
    window.addEventListener('keyup', e=>{ this.keys[e.key] = false; });

    // touch buttons
    const mapBtn = (id,key,action)=>{
      const el = document.getElementById(id);
      if(!el) return;
      let active=false;
      el.addEventListener('touchstart', e=>{ e.preventDefault(); active=true; this.keys[key]=true; if(action) action(); });
      el.addEventListener('touchend', e=>{ e.preventDefault(); active=false; this.keys[key]=false; });
      el.addEventListener('mousedown', e=>{ e.preventDefault(); active=true; this.keys[key]=true; if(action) action(); });
      el.addEventListener('mouseup', e=>{ e.preventDefault(); active=false; this.keys[key]=false; });
    };
    mapBtn('btnUp','ArrowUp');
    mapBtn('btnDown','ArrowDown');
    mapBtn('btnLeft','ArrowLeft');
    mapBtn('btnRight','ArrowRight');
    mapBtn('btnSteal','s', ()=> { if(this.userPlayer) { this.userPlayer.trySteal(this.ball,this); } });
    mapBtn('btnShoot','Space', ()=> { if(this.userPlayer) { this.userPlayer.attemptShoot(this.ball,1.0,this); } });
  }

  loop(){
    const now = performance.now();
    const dt = Math.min(40, now - this.lastFrame);
    this.lastFrame = now;

    this.update(dt);
    this.render();

    requestAnimationFrame(()=>this.loop());
  }

  update(dt){
    if(!this.levelInProgress) return;
    // user controls
    const speed = 3.2 * (0.8 + this.userPlayer.stamina*0.4);
    if(this.userPlayer && !this.userPlayer.isRemoved){
      let mx=0,my=0;
      if(this.keys['ArrowLeft']) mx=-1;
      if(this.keys['ArrowRight']) mx=1;
      if(this.keys['ArrowUp']) my=-1;
      if(this.keys['ArrowDown']) my=1;
      // normalize
      const mag = Math.sqrt(mx*mx + my*my) || 1;
      this.userPlayer.vx += (mx/mag) * speed * 0.18;
      this.userPlayer.vy += (my/mag) * speed * 0.18;
      // clamp speed
      const sp = Math.sqrt(this.userPlayer.vx*this.userPlayer.vx + this.userPlayer.vy*this.userPlayer.vy);
      const maxSp = speed * 1.6;
      if(sp > maxSp){ this.userPlayer.vx = this.userPlayer.vx/sp*maxSp; this.userPlayer.vy = this.userPlayer.vy/sp*maxSp; }
    }

    // update players
    for(const p of this.players) p.update(dt, this);

    // ball update
    this.ball.update();

    // collision: if ball free and player near -> take possession
    if(!this.ball.possessedBy){
      for(const p of this.players){
        if(p.isRemoved) continue;
        const d = distanceXY(this.ball.x,this.ball.y,p.x,p.y);
        if(d < p.radius + this.ball.radius + 4){
          // player takes ball
          p.hasBall = true;
          this.ball.possessedBy = p;
          this.ball.lastTouchedBy = p;
          this.onPossessionChange(p);
          break;
        }
      }
    }

    // handle goals: if ball crosses within goal area (x near 1200 or 0 and y in goal band)
    if(this.ball.lastTouchedBy){
      const gTop=300, gBottom=500;
      if(this.ball.x > 1190 && this.ball.y > gTop && this.ball.y < gBottom){
        // home team scores if lastTouchedBy is home
        this.onGoal(this.ball.lastTouchedBy);
      }
      if(this.ball.x < 10 && this.ball.y > gTop && this.ball.y < gBottom){
        this.onGoal(this.ball.lastTouchedBy);
      }
    }

    // out-of-bounds detection: if ball touched edge flagged earlier
    if(this.ball.outTouched){
      // find last toucher and red card them and award free kick to opposite team
      const offender = this.ball.lastTouchedBy;
      if(offender && !offender.isUser){ // if the offender is opponent or user, red card them
        offender.isRemoved = true;
        // remove from players array visually (they won't act)
        this.message = `${offender.number} got a red card! Free kick awarded.`;
        this.ref.blowWhistle();
        // place ball for free kick near center-right/left depending
        if(offender.isHome){
          // home offender removed -> away gets free-kick
          this.ball.x = clamp(offender.x + 30, 100, 1100);
          this.ball.y = offender.y;
          this.ball.vx = 0; this.ball.vy=0;
          this.ball.possessedBy = null;
        } else {
          // away offender removed -> home gets free-kick
          this.ball.x = clamp(offender.x - 30, 100, 1100);
          this.ball.y = offender.y;
          this.ball.vx = 0; this.ball.vy=0;
          this.ball.possessedBy = null;
        }
      }
      this.ball.outTouched = false;
    }

    // update referee
    this.ref.update();

    // possession timer: if opponent has ball, start timer countdown for stealing
    if(this.ball.possessedBy && this.ball.possessedBy.isHome !== this.userPlayer.isHome){
      if(this.possessionOwner !== this.ball.possessedBy){
        this.possessionOwner = this.ball.possessedBy;
        this.possessionTimer = 5000; // ms
      } else {
        this.possessionTimer -= dt;
        if(this.possessionTimer <= 0){
          // user failed to steal within 5s -> lose a life and reset possession
          this.lives -= 1;
          this.hud.livesText.innerText = `Lives: ${this.lives}`;
          this.hud.message.innerText = 'You failed to recover ball ‚Äî life lost!';
          // reset: give ball to random opponent further away
          const others = this.players.filter(p => !p.isUser && !p.isRemoved);
          if(others.length){
            const newHolder = others[Math.floor(Math.random()*others.length)];
            for(const p of this.players){ p.hasBall=false; }
            newHolder.hasBall = true; this.ball.possessedBy = newHolder; this.ball.lastTouchedBy = newHolder;
            this.onPossessionChange(newHolder);
          }
          this.possessionOwner = null;
          this.possessionTimer = 0;
          // check lose
          if(this.lives <= 0){
            this.onLose();
          }
        }
      }
    } else {
      this.possessionOwner = null;
      this.possessionTimer = 0;
    }

    // UI updates
    this.hud.possessionText.innerText = `Possession: ${this.ball.possessedBy ? (this.ball.possessedBy.isHome ? 'User Team' : 'Opponents') : 'Free'}`;
    this.hud.stealTimerText.innerText = this.possessionTimer > 0 ? `Steal timer: ${(this.possessionTimer/1000).toFixed(1)}s` : 'Steal timer: --';
    this.hud.message.innerText = this.message;

    // goal popup timer
    if(this.goalPopupTimer > 0){ this.goalPopupTimer -= dt; if(this.goalPopupTimer <= 0) this.goalTextEl.style.display='none'; }

    // Level difficulty progression: slight stat bump for opponents each update
    // (already baked into initial createLevel speed/shooting param)
  }

  render(){
    const ctx = this.ctx;
    ctx.clearRect(0,0,this.canvas.width,this.canvas.height);

    // draw pitch markings
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0,0,1200,800);
    // center line
    ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(600,0); ctx.lineTo(600,800); ctx.stroke();
    // center circle
    ctx.beginPath(); ctx.arc(600,400,80,0,Math.PI*2); ctx.stroke();
    // goals rectangles
    ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(1188,300,24,200); ctx.fillRect(-12,300,24,200);
    ctx.restore();

    // draw players: away then user (so user on top)
    const away = this.players.filter(p => !p.isUser).sort((a,b)=>a.number-b.number);
    for(const p of away) p.draw(ctx);
    for(const p of this.players.filter(p=>p.isUser)) p.draw(ctx);

    // ball
    this.ball.draw(ctx);

    // referee
    this.ref.draw(ctx);

    // overlays: draw life small icons
    // draw HUD overlays are DOM elements already
  }

  onPossessionChange(player, initial=false){
    // called when a player picks ball
    this.message = `${player.isUser ? 'User' : 'Opponent'} took possession (#${player.number})`;
    // reset possession timer if opponent took ball
    if(player.isHome !== this.userPlayer.isHome){
      this.possessionOwner = player;
      this.possessionTimer = 5000;
    } else {
      this.possessionOwner = null; this.possessionTimer = 0;
    }
  }

  onShot(player){
    this.message = `${player.isUser ? 'User' : 'Opponent'} shot!`;
    // if shot by user, maybe give extra velocity; already handled in Player.attemptShoot
  }

  onPass(from,to){
    this.message = `Pass from #${from.number} to #${to.number}`;
  }

  onGoal(lastTouch){
    if(!lastTouch) return;
    const scorerIsUser = lastTouch.isUser;
    // scoring only counts when ball crosses goal line near goal band; determine which team scored based on direction
    // show GOALLLL!
    this.goalTextEl.style.display='block'; this.goalPopupTimer = 1600;
    this.goalTextEl.innerText = 'GOALLLL!!!';
    // If user scored -> win this level
    if(scorerIsUser){
      this.onWin();
    } else {
      // opponent scored -> deduct life (because user failed to defend quickly)
      this.lives -= 1;
      this.hud.livesText.innerText = `Lives: ${this.lives}`;
      if(this.lives <= 0) this.onLose();
      else {
        this.message = 'Opponent scored ‚Äî life lost!';
        // reset ball to center with random opponent possession
        this.ball.x = 600; this.ball.y = 400; this.ball.vx=0; this.ball.vy=0;
        // give ball to an opponent
        const opps = this.players.filter(p=>!p.isUser && !p.isRemoved);
        if(opps.length){
          const h = opps[Math.floor(Math.random()*opps.length)];
          for(const p of this.players) p.hasBall=false;
          h.hasBall=true; this.ball.possessedBy=h; this.ball.lastTouchedBy=h;
          this.onPossessionChange(h);
        }
      }
    }
  }

  onWin(){
    this.levelInProgress = false;
    this.winOverlay.classList.add('show');
  }

  onLose(){
    this.levelInProgress = false;
    this.loseOverlay.classList.add('show');
  }

  restartLevel(){
    this.winOverlay.classList.remove('show');
    this.loseOverlay.classList.remove('show');
    this.lives = 7;
    this.createLevel(this.level);
  }

  nextLevel(){
    this.winOverlay.classList.remove('show');
    if(this.level < this.maxLevel) this.level++;
    this.createLevel(this.level);
  }
}

// Kick off
const canvas = document.getElementById('gameCanvas');
canvas.style.width = '100%';
canvas.style.height = '100%';
canvas.style.maxWidth = '100vw';
canvas.style.maxHeight = '100vh';
const game = new Game(canvas);

</script>
</body>
</html>
